__cont_source_scripts()
{
    local i
    local dir="$1"
    for i in "$dir"/*.sh; do
        if test -r "$i"; then
            . "$i"
        fi
    done
}


# CONT_SOURCE_HOOKS HOOKDIR [PROJECT]
# -----------------------------------
# Source '*.sh' files from the following directories (in this order):
#   a. @contlayerhookdir@/PROJECT/HOOK/
#   b. @contvolumehookdir@/PROJECT/HOOK/
#
# The PROJECT argument is optional because it may be set globally by
# $CONT_PROJECT environment variable.  The need for PROJECT argument is
# basically to push people to install script into theirs own directories,
# which will allow easier multi-project containers maintenance.
cont_source_hooks()
{
    local i dir
    local hook="$1"
    local project="$CONT_PROJECT"
    local dir

    test -z "$hook" && return
    test -n "$2" && project="$2"

    for dir in @contlayerhookdir@ @contvolumehookdir@; do
        dir="$dir/$project/$hook"
        cont_debug2 "loading scripts from $dir"
        __cont_source_scripts "$dir"
    done
}

__cont_msg()
{
    echo "$*" >&2
}

cont_warn()
{
    __cont_msg "warn: $*"
}

cont_error()
{
    __cont_msg "error: $*"
}

: ${CONT_DEBUG=0}

__cont_dbg()
{
    test -z "$CONT_DEBUG" && CONT_DEBUG=0
    test "$CONT_DEBUG" -lt "$1" && return
    local lvl="$1"
    shift
    __cont_msg "debug_$lvl: $*"
}

cont_debug()  { __cont_dbg 1 "$*" ; }
cont_debug2() { __cont_dbg 2 "$*" ; }
cont_debug3() { __cont_dbg 3 "$*" ; }


# SEMICOLON_SPLIT VAR
# -------------------
# Split the contents of string variable VAR into list of strings (on separate
# line), each of those strings will be printed to standard output.  The ';' and
# newline characters are used as split separators.  You can use quadrigraph @.,@
# for ';' character not splitting the VAR (and use @&t@ to expand into empty
# string).  More info about quadrigraphs may be found in autoconf info page.
cont_semicolon_split()
{
    eval set -- "\"\$$1\""
    test x = x"$1" && return 0

    echo "$1" \
        | sed \
            -e 's/[[:space:]]*;[[:space:]]*/\n/g' \
        | sed \
            -e 's|@.,@|;|g' \
            -e 's|@&t@||g'
}

# CONT_PARSER_SIMPLE_CONFIG CONFIG_VAR CALLBACK [ARGS]
# ----------------------------------------------------
# Parse contents of variable of name CONFIG_VAR, call CALLBACK function (or
# command) for each parsed configuration option.
#
# The format of configuration file is:
#
#   <key> = <value> [; ...]
#
# Content of <key> is not limited, but keep it sane please (lets say we support
# the C syntax of identifiers).  The <value> must be single-line string.  Should
# the <value> contain ';' or '\' character, it must be escaped by '\'.
#
# The semantics of CALLBACK you *must* provide is:
#
#   CALLBACK KEY VALUE [ARGS]
#   -------------------------
#   KEY and VALUE are strings with parsed result.  ARGS is additional payload
#   you may provide during CONTAINER_SIMPLE_CONFIG_PARSER call.
#
# Example of usage:
#
#   $ cat script.sh
#   callback()
#   {
#       local var="$1" val="$2"
#       shift 2
#       test -n "$*" && local payload=" [$*]"
#       echo "$var=$val$payload"
#   }
#   config='URL = "http://example.com"; semicolon = "@.,@"'
#   cont_parser_simple_config config callback additional data
#
#   $ ./script
#   URL="http://example.com" [additional data]
#   semicolon=";" [additional data]
cont_parser_simple_config()
{
    local conf_var="$1"
    local callback="$2"
    shift 2

    while read line; do
        test -z "$line" && continue
        if [[ $line =~ ^([^[:space:]]+)[[:space:]]*=[[:space:]]*(.*)$ ]]
        then
            local k="${BASH_REMATCH[1]}" v="${BASH_REMATCH[2]}"
            cont_debug3 "calling callback with: $k = $v"
            "$callback" "$k" "$v" "$@" || {
                cont_error "$FUNCNAME: callback failed"
                return 1
            }
        else
            cont_warn "wrong config: $line"
        fi
    done < <(cont_semicolon_split "$conf_var")

    return 0
}


__cont_encode_env()
{
    local i
    for i in $1
    do
        eval local val="\$$i"
        printf ": \${%s=%q}\n" "$i" "$val"
    done
}


# CONT_STORE_ENV VARIABLES FILENAME
# ---------------------------------
# Create source-able script conditionally setting specified VARIABLES by
# inheritting the values from current environment; Create the file on path
# FILENAME.  Already existing variables will not be changed by sourcing the
# resulting script.  The argument VARIABLES expects list of space separated
# variable names.
#
# Usage:
#   $ my_var=my_value
#   $ my_var2="my value2"
#   $ cont_store_env "my_var my_var2" ~/.my-environment
#   $ cat ~/.my-environment
#   : ${my_var=my_value}
#   : ${my_var2=my\ value2}
cont_store_env()
{
    cont_debug "creating env file '$2'"
    __cont_encode_env "$1" > "$2" \
        || cont_warn "can't store environment $1 into $2 file"
}


__cont_source_scripts "@autoloaddir@"
